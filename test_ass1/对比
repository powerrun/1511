            if (command == 'w') {
                if (player_row - 1 >= 0 && 
                    (map[player_row - 1][player_col].type == BUSH || 
                    map[player_row - 1][player_col].type == FLOWER)) {
                    map[player_row - 1][player_col].type = EMPTY;
                }
            }
            else if (command == 'a') {
                if (player_col - 1 >= 0 && 
                    (map[player_row][player_col - 1].type == BUSH || 
                    map[player_row][player_col - 1].type == FLOWER)) {
                    map[player_row][player_col - 1].type = EMPTY;
                }
            }
            else if (command == 's') {
                if (player_row + 1 <= MAX_ROW - 1 && 
                    (map[player_row + 1][player_col].type == BUSH || 
                    map[player_row + 1][player_col].type == FLOWER)) {
                    map[player_row + 1][player_col].type = EMPTY;
                }
            }
            else if (command == 'd') {
                if (player_col + 1 <= MAX_COL - 1 && 
                    (map[player_row][player_col + 1].type == BUSH || 
                    map[player_row][player_col + 1].type == FLOWER)) {
                    map[player_row][player_col + 1].type = EMPTY;
                }
            }





// 2.4
唤醒
    for (int alert_row = player_row - 2; alert_row <= player_row + 2; alert_row++) {
        for (int alert_col = player_col - 2; alert_col <= player_col + 2; alert_col++) {
            if (alert_row >= 0 && alert_row < MAX_ROW && 
                alert_col >= 0 && alert_col < MAX_COL && 
                map[alert_row][alert_col].type == FLOWER) {
                if (map[alert_row][alert_col].flower.state == DORMANT) {
                    map[alert_row][alert_col].flower.state = DISTURBED;
                }
                else {
                    map[alert_row][alert_col].flower.state = AWAKENED;
                }
            }
        }
    }





// 2.2 重做吧

// stage 2.2 - 2.4

void player_action(struct tile map[MAX_ROW][MAX_COL], int player_row, int player_col) {
    char command, cut_direction;
    printf("Game Started!\nEnter command: ");
    int return_val = scanf(" %c", &command);
    // will exit when user press ctrl + d
    int alert = FALSE;

    while (return_val == 1) {
        if (command == 'w') {
            if (player_row - 1 >= 0 && 
                (map[player_row - 1][player_col].type == EMPTY)) {
                player_row -= 1;
            }
            else if (player_row - 1 >= 0 && 
                map[player_row - 1][player_col].type == BRANCH) {
                map[player_row - 1][player_col].type = EMPTY;
                player_row -= 1;
                alert = TRUE;
            }
        }
        else if (command == 'a') {
            if (player_col - 1 >= 0 && 
                (map[player_row][player_col - 1].type == EMPTY)) {
                player_col -= 1;
            }
            else if (player_col - 1 >= 0 && 
                map[player_row][player_col - 1].type == BRANCH) {
                map[player_row][player_col - 1].type = EMPTY;
                player_col -= 1;
                alert = TRUE;
            }
        }
        else if (command == 's') {
            if (player_row + 1 <= MAX_ROW - 1 && 
                (map[player_row + 1][player_col].type == EMPTY)) {
                player_row += 1;
            }
            else if (player_row + 1 <= MAX_ROW - 1 && 
                map[player_row + 1][player_col].type == BRANCH) {
                map[player_row + 1][player_col].type = EMPTY;
                player_row += 1;
                alert = TRUE;
            }
        }
        else if (command == 'd') {
            if (player_col + 1 <= MAX_COL - 1 && 
                (map[player_row][player_col + 1].type == EMPTY)) {
                player_col += 1;
            }
            else if (player_col + 1 <= MAX_COL - 1 && 
                map[player_row][player_col + 1].type == BRANCH) {
                map[player_row][player_col + 1].type = EMPTY;
                player_col += 1;
                alert = TRUE;
            }
        }

        // stage 2.3: Cutting Flowers
        else if (command == 'c') {
            scanf(" %c", &cut_direction);
            
            if (cut_direction == 'w') {
                if (player_row - 1 >= 0 && map[player_row - 1][player_col].type == BUSH) {
                    map[player_row - 1][player_col].type = EMPTY;
                }
                else if (player_row - 1 >= 0 && map[player_row - 1][player_col].type == FLOWER) {
                    map[player_row - 1][player_col].type = EMPTY;
                }
            }
            else if (cut_direction == 'a') {
                if (player_col - 1 >= 0 && map[player_row][player_col - 1].type == BUSH) {
                    map[player_row][player_col - 1].type = EMPTY;
                }
                else if (player_col - 1 >= 0 && map[player_row][player_col - 1].type == FLOWER) {
                    map[player_row][player_col - 1].type = EMPTY;
                }
            }
            else if (cut_direction == 's') {
                if (player_row + 1 <= MAX_ROW - 1 && map[player_row + 1][player_col].type == BUSH) {
                    map[player_row + 1][player_col].type = EMPTY;
                    alert = TRUE;
                }
                else if (player_row + 1 <= MAX_ROW - 1 && map[player_row + 1][player_col].type == FLOWER) {
                    map[player_row + 1][player_col].type = EMPTY;
                }
            }
            else if (cut_direction == 'd') {
                if (player_col + 1 <= MAX_COL - 1 && map[player_row][player_col + 1].type == BUSH) {
                    map[player_row][player_col + 1].type = EMPTY;
                    alert = TRUE;
                }
                else if (player_col + 1 <= MAX_COL - 1 && map[player_row][player_col + 1].type == FLOWER) {
                    map[player_row][player_col + 1].type = EMPTY;
                }
            }
            alert = TRUE;
        }
        else {
            // stay still
        }

        // call alerting_flowers
        if (alert == TRUE) {
            alerting_flowers(map, player_row, player_col);
            alert = FALSE;
        }

        print_map(map, player_row, player_col);

        printf("Enter command: ");
        return_val = scanf(" %c", &command);
    }
}

// stage 2.4: Alerting Flowers
void alerting_flowers(struct tile map[MAX_ROW][MAX_COL], int player_row, int player_col) {
    // Calculate alert boundaries
    int min_alert_row, max_alert_row, min_alert_col, max_alert_col;
    min_alert_row = player_row - 2;
    min_alert_col = player_col - 2;
    max_alert_row = player_row + 2;
    max_alert_col = player_col + 2;

    // Alerting flowers
    for (int alert_row = min_alert_row; alert_row <= max_alert_row; alert_row++) {
        for (int alert_col = min_alert_col; alert_col <= max_alert_col; alert_col++) {
            if (alert_row >= 0 && alert_row < MAX_ROW && alert_col >= 0 && alert_col < MAX_COL && 
                map[alert_row][alert_col].type == FLOWER) 
            {
                if (map[alert_row][alert_col].flower.state == DORMANT) {
                    map[alert_row][alert_col].flower.state = DISTURBED;
                }
                else {
                    map[alert_row][alert_col].flower.state = AWAKENED;
                }
            }
        }
    }
}



















// alert 统一一个函数

        for (result.alert_row = result.player_row - 2; result.alert_row <= result.player_row + 2; result.alert_row++) {
            for (result.alert_col = result.player_col - 2; result.alert_col <= result.player_row + 2; result.alert_col++) {
                if (result.alert_row >= 0 && result.alert_row < MAX_ROW && 
                    result.alert_col >= 0 && result.alert_col < MAX_COL && 
                    map[result.alert_row][result.alert_col].type == FLOWER) 
                {
                    if (map[result.alert_row][result.alert_col].flower.state == DORMANT) {
                        map[result.alert_row][result.alert_col].flower.state = DISTURBED;
                    }
                    else if (map[result.alert_row][result.alert_col].flower.state == DISTURBED) {
                        map[result.alert_row][result.alert_col].flower.state = AWAKENED;
                    }
                }
            }
        }


// 花，alert之前先计算alert中心
    char direction;
    scanf(" %c", &direction);
    if (direction == 'w') {
        result.alert_row = result.player_row - 1;
        result.alert_col = result.player_col;
    }
    else if (direction == 's') {
        result.alert_row = result.player_row + 1;
        result.alert_col = result.player_col;
    }
    else if (direction == 'a') {
        result.alert_row = result.player_row;
        result.alert_col = result.player_col - 1;
    }
    else if (direction == 'd') {
        result.alert_row = result.player_row;
        result.alert_col = result.player_col + 1;
    }



// Function to handle player actions during the game
struct result action(struct tile map[MAX_ROW][MAX_COL], struct result result) {
    // Variable to store the command entered by the player
    char command;
    
    // Prompt the player to start the game and enter a command
    printf("Game Started!\nEnter command: ");
    
    // Read the first command entered by the player
    int return_val = scanf(" %c", &command);

    // Continue executing commands as long as a valid command is entered
    while (return_val == 1) {
        // Determine the action based on the command entered by the player
        if (command == 'c') {
            // If the command is to cut, call the cut_flower function
            result = cut_flower(map, result);
        }
        else {
            // If the command is to move, call the move_player function
            result = move_player(map, result, command);
        }
        
        // Print the updated map after each action
        print_map(map, result.player_row, result.player_col);

        // Check the game status to determine whether to continue
        result.game_alive = check_game_status(map, result);
        if (result.game_alive == TRUE) {
            // If the game is still ongoing, prompt the player for the next command
            printf("Enter command: ");
            return_val = scanf(" %c", &command);
        }
        else {
            // If the game is over, break out of the loop
            break;
        }
    }
    
    // Return the final result of the game
    return result;
}
